<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Midible Example</title>
    <link rel="stylesheet" href="styles.css">
    <script src="http://unpkg.com/tone"></script>
</head>
<body>
<h1>MIDI Recorder and Player</h1>
<p>Record MIDI input from a BLE MIDI device and play it back in the browser.</p>

<button id="connect">Connect BLE MIDI Device</button>
<button id="start-recording" disabled>Start Recording</button>
<button id="stop-recording" disabled>Stop Recording</button>
<button id="play-recording" disabled>Play Recording</button>

<div class="log" id="log">Logs will appear here...</div>

<script type="module">
    import {
        DeviceConnector,
        MIDI_SERVICE_UID,
        MIDI_IO_CHARACTERISTIC_UID,
        MidiPacketParser,
    } from "../dist/midible.es.js";

    let connectDevice = null;
    const midiPacketParser = new MidiPacketParser()
    const logElement = document.getElementById("log");
    let recordingStartTime = null;
    let recordedEvents = [];


    function logMessage(message) {
        if (typeof message === "object" && message !== null) {
            // オブジェクトを整形して表示
            const formattedMessage = `<pre>${JSON.stringify(message, null, 2)}</pre>`;
            logElement.innerHTML += `<div>${formattedMessage}</div>`;
        } else {
            // 通常の文字列をそのまま表示
            logElement.innerHTML += `<div>${message}</div>`;
        }
        // スクロールを最新メッセージに合わせる
        logElement.scrollTop = logElement.scrollHeight;
    }


    document.getElementById("connect").addEventListener("click", async () => {
        try {
            logMessage("Requesting Bluetooth MIDI device...");
            const device = await DeviceConnector.connect();

            logMessage(`Connected to: ${device.name || "Unknown Device"}`);
            connectDevice = device;

            connectDevice.addEventListener('gattserverdisconnected', onDisconnected);

            const server = await connectDevice.gatt.connect();
            const service = await server.getPrimaryService(MIDI_SERVICE_UID);
            const characteristic = await service.getCharacteristic(MIDI_IO_CHARACTERISTIC_UID);

            await characteristic.startNotifications();
            characteristic.addEventListener('characteristicvaluechanged', handleMidiMessageReceived);

            logMessage("Connected to MIDI service. Ready to receive messages.");
            document.getElementById("start-recording").disabled = false;
        } catch (error) {
            logMessage(`Error: ${error.message}`);
        }
    });

    document.getElementById("start-recording").addEventListener("click", () => {
        logMessage("Starting recording...");
        recordingStartTime = Date.now();
        recordedEvents = [];
        midiPacketParser.clear();
        document.getElementById("stop-recording").disabled = false;
        document.getElementById("start-recording").disabled = true;
    });

    document.getElementById("stop-recording").addEventListener("click", async () => {
        logMessage("Stopping recording...");
        document.getElementById("play-recording").disabled = false;
        document.getElementById("stop-recording").disabled = true;

        // Allow playback
        document.getElementById("play-recording").addEventListener("click", () => {
            playMidiFile();
        });
    });

    let loggedIndex = 0;

    function handleMidiMessageReceived(event) {
        midiPacketParser.parse(new Uint8Array(event.target.value.buffer));
        const processedMessages = midiPacketParser.processedMessages;

        // ログ出力する新しいメッセージがあるか確認
        if (processedMessages.length > loggedIndex) {
            // 新しいメッセージをループでロギング
            for (let i = loggedIndex; i < processedMessages.length; i++) {
                const midiEvent = processedMessages[i];
                logMessage(midiEvent);
                // 録音中の場合はイベントを記録
                if (recordingStartTime !== null) {
                    recordedEvents.push({
                        ...midiEvent,
                        recordingTimestamp: midiEvent.createdAt - recordingStartTime,
                    });
                }
            }
            // インデックスを更新
            loggedIndex = processedMessages.length;
        }
    }

    function playMidiFile() {
        if (recordedEvents.length === 0) {
            logMessage("No recorded events to play.");
            return;
        }
        logMessage("Playing MIDI recording...");
        const synth = new Tone.PolySynth(Tone.Synth).toDestination();
        const now = Tone.now();

        recordedEvents.forEach((event) => {
            const timeInSeconds = now + event.recordingTimestamp / 1000;
            if (event.status.name === "Note On") {
                const note = `${event.data.notes[0]}${event.data.octave}`;
                const scaledVelocity = event.data.velocity / 127.0;
                console.log('on', note, timeInSeconds, scaledVelocity);
                synth.triggerAttack(note, timeInSeconds, scaledVelocity);
            } else if (event.status.name === "Note Off") {
                const note = `${event.data.notes[0]}${event.data.octave}`;
                console.log('off', note, timeInSeconds);
                synth.triggerRelease(note, timeInSeconds);
            }
        });
    }

    function onDisconnected() {
        logMessage("Device disconnected.");
        midiPacketParser.clear();
        document.getElementById("connect").disabled = false;
        document.getElementById("start-recording").disabled = true;
        document.getElementById("stop-recording").disabled = true;
        document.getElementById("play-recording").disabled = true;
    }
</script>
</body>
</html>
